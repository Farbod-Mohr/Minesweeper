#include <unordered_map>
#include <string>
#include <string_view>
#include <vector>
#include "../include/Board.h"
#include "../include/Cell.h"
#include <cassert>
#include <iostream>

// ! UNIT TESTS ARE GENERATED BY GITHUB COPILOT. !
// ? Prompt used: Create testing units for checkpoint 3. Checkpoint 3 is the algorithm used to place down mines and all the functions associated with it. ? //
// * AI Used: Claude Opus 4.5 (Preview) * //

// ========= Test Helper Class ========= //
// Since Board has many private/protected members, we create a TestBoard class that inherits from Board
// to expose the necessary functionality for testing the mine placement algorithm.
class TestBoard : public Board
{
public:
    TestBoard(int rows, int cols, int mineCount) : Board(rows, cols, mineCount) {}

    // Expose the grid for testing
    std::vector<std::vector<Cell>> &getGrid() { return grid; }

    // Expose cell access for testing
    Cell &testGetCell(int r, int c) { return grid[r][c]; }

    // Expose mine placement algorithm helpers
    bool testFormsTwoByTwo(int r, int c) const { return formsTwoByTwo(r, c); }
    bool testFormsLongLine(int r, int c) const { return formsLongLine(r, c); }
    bool testTrapsSafeCell(int r, int c) const { return trapsSafeCell(r, c); }
    int testMakeKey(int r, int c) const { return makeKey(r, c); }
    bool testIsBlacklisted(int key, const std::unordered_map<int, bool> &blacklist) const
    {
        return isBlacklisted(key, blacklist);
    }

    // Expose placeMines for testing
    void testPlaceMines(int safeX, int safeY) { placeMines(safeX, safeY); }

    // Expose calcAdjacentMines for testing
    void testCalcAdjacentMines() { calcAdjacentMines(); }

    // Expose counters for testing
    int getRows() const { return rows; }
    int getCols() const { return cols; }
    int getTotalCells() const { return totalCells; }
    int getMineCount() const { return mineCount; }

    // Helper to count total mines on the board
    int countTotalMines() const
    {
        int count = 0;
        for (int r = 1; r < rows - 1; r++)
        {
            for (int c = 1; c < cols - 1; c++)
            {
                if (grid[r][c].hasMine)
                {
                    count++;
                }
            }
        }
        return count;
    }

    // Helper to check if a cell is in the safe zone
    bool isInSafeZone(int r, int c, int safeX, int safeY) const
    {
        return (r >= safeY - 1 && r <= safeY + 1) && (c >= safeX - 1 && c <= safeX + 1);
    }
};

// ========= Test 1: Normal Operation - Mine Placement Basic Functionality ========= //
void testNormalOperation()
{
    std::cout << "Test 1: Normal Operation (Mine Placement Basic Functionality)...";

    // Create a 9x9 board with 10 mines (Easy difficulty)
    TestBoard board(9, 9, 10);

    // Place mines with safe zone at (5, 5) - center of the board
    board.testPlaceMines(5, 5);

    // Verify mines were placed
    int mineCount = board.countTotalMines();
    assert(mineCount > 0);   // At least some mines should be placed
    assert(mineCount <= 10); // Should not exceed requested amount

    // Verify safe zone (3x3 around position 5,5) has no mines
    for (int r = 4; r <= 6; r++)
    {
        for (int c = 4; c <= 6; c++)
        {
            Cell &cell = board.testGetCell(r, c);
            assert(!cell.hasMine); // Safe zone should have no mines
        }
    }

    std::cout << " PASSED\n";
}

// ========= Test 2: Edge Case - formsTwoByTwo Detection ========= //
void testFormsTwoByTwo()
{
    std::cout << "Test 2: Edge Case (formsTwoByTwo Detection)...";

    // Create a small board for testing
    TestBoard board(5, 5, 0);

    // Manually place 2 mines in a 2x2 pattern
    board.testGetCell(2, 2).setHasMine(true);
    board.testGetCell(2, 3).setHasMine(true);

    // Adding a third mine at (3, 2) would create a 2x2 with 3 mines
    // The pattern check should detect this
    bool wouldForm = board.testFormsTwoByTwo(3, 2);

    // Before placing the mine, temporarily set it to check
    board.testGetCell(3, 2).setHasMine(true);
    bool formsPattern = board.testFormsTwoByTwo(3, 2);
    board.testGetCell(3, 2).setHasMine(false);

    // With 3 mines in a 2x2, the check should return true
    assert(formsPattern == true);

    // Test case where no 2x2 pattern forms
    TestBoard cleanBoard(5, 5, 0);
    cleanBoard.testGetCell(1, 1).setHasMine(true);
    cleanBoard.testGetCell(3, 3).setHasMine(true); // Far apart, no 2x2

    bool noPattern = cleanBoard.testFormsTwoByTwo(1, 3); // Checking a cell not forming pattern
    // This should not form a 2x2 with 3+ mines
    assert(noPattern == false);

    std::cout << " PASSED\n";
}

// ========= Test 3: Edge Case - formsLongLine Detection ========= //
void testFormsLongLine()
{
    std::cout << "Test 3: Edge Case (formsLongLine Detection)...";

    // Create a board for testing
    TestBoard board(9, 9, 0);

    // Place 3 consecutive horizontal mines
    board.testGetCell(5, 2).setHasMine(true);
    board.testGetCell(5, 3).setHasMine(true);
    board.testGetCell(5, 4).setHasMine(true);

    // Adding a 4th mine at (5, 5) would create a line of 4
    board.testGetCell(5, 5).setHasMine(true);
    bool formsLine = board.testFormsLongLine(5, 5);
    assert(formsLine == true); // Should detect 4+ mines in a row

    // Test vertical line
    TestBoard vertBoard(9, 9, 0);
    vertBoard.testGetCell(2, 5).setHasMine(true);
    vertBoard.testGetCell(3, 5).setHasMine(true);
    vertBoard.testGetCell(4, 5).setHasMine(true);
    vertBoard.testGetCell(5, 5).setHasMine(true);

    bool formsVertLine = vertBoard.testFormsLongLine(5, 5);
    assert(formsVertLine == true); // Should detect vertical line of 4

    // Test case where no long line forms
    TestBoard noLineBoard(9, 9, 0);
    noLineBoard.testGetCell(3, 3).setHasMine(true);
    noLineBoard.testGetCell(3, 4).setHasMine(true);
    noLineBoard.testGetCell(3, 5).setHasMine(true); // Only 3 in a row

    bool noLine = noLineBoard.testFormsLongLine(3, 5);
    assert(noLine == false); // 3 mines don't form a "long line" (need 4+)

    std::cout << " PASSED\n";
}

// ========= Test 4: Edge Case - trapsSafeCell Detection ========= //
void testTrapsSafeCell()
{
    std::cout << "Test 4: Edge Case (trapsSafeCell Detection)...";

    // Create a small board
    TestBoard board(5, 5, 0);

    // Create a scenario where a cell would be trapped
    // Surround cell (3, 3) with mines on all sides except one
    board.testGetCell(2, 2).setHasMine(true);
    board.testGetCell(2, 3).setHasMine(true);
    board.testGetCell(2, 4).setHasMine(true);
    board.testGetCell(3, 2).setHasMine(true);
    board.testGetCell(3, 4).setHasMine(true);
    board.testGetCell(4, 2).setHasMine(true);
    board.testGetCell(4, 3).setHasMine(true);
    // Cell (4, 4) is the last opening - if we place a mine there, (3,3) is trapped

    board.testGetCell(4, 4).setHasMine(true);
    bool traps = board.testTrapsSafeCell(4, 4);
    assert(traps == true); // Should detect that this traps a safe cell

    // Test case where no cell is trapped
    TestBoard openBoard(5, 5, 0);
    openBoard.testGetCell(2, 2).setHasMine(true);
    openBoard.testGetCell(2, 4).setHasMine(true); // Mines with gaps

    bool noTrap = openBoard.testTrapsSafeCell(2, 3);
    assert(noTrap == false); // Should not trap any cell

    std::cout << " PASSED\n";
}

// ========= Test 5: Boundary Conditions - makeKey and isBlacklisted ========= //
void testKeyAndBlacklist()
{
    std::cout << "Test 5: Boundary Conditions (makeKey & isBlacklisted)...";

    TestBoard board(9, 9, 0);

    // Test makeKey produces unique keys for different positions
    int key1 = board.testMakeKey(1, 1);
    int key2 = board.testMakeKey(1, 2);
    int key3 = board.testMakeKey(2, 1);
    int key4 = board.testMakeKey(5, 5);

    assert(key1 != key2);
    assert(key1 != key3);
    assert(key2 != key3);
    assert(key1 != key4);

    // Test isBlacklisted
    std::unordered_map<int, bool> blacklist;

    // Initially, no keys are blacklisted
    assert(board.testIsBlacklisted(key1, blacklist) == false);
    assert(board.testIsBlacklisted(key2, blacklist) == false);

    // Add key1 to blacklist
    blacklist[key1] = true;
    assert(board.testIsBlacklisted(key1, blacklist) == true);
    assert(board.testIsBlacklisted(key2, blacklist) == false);

    // Add more keys
    blacklist[key3] = true;
    assert(board.testIsBlacklisted(key3, blacklist) == true);
    assert(board.testIsBlacklisted(key4, blacklist) == false);

    std::cout << " PASSED\n";
}

// ========= Test 6: Normal Operation - calcAdjacentMines ========= //
void testCalcAdjacentMines()
{
    std::cout << "Test 6: Normal Operation (calcAdjacentMines)...";

    // Create a board and manually place mines
    TestBoard board(5, 5, 0);

    // Place a mine at (3, 3)
    board.testGetCell(3, 3).setHasMine(true);

    // Calculate adjacent mines
    board.testCalcAdjacentMines();

    // All 8 cells around (3, 3) should have adjacentMinesCount = 1
    assert(board.testGetCell(2, 2).adjacentMinesCount == 1);
    assert(board.testGetCell(2, 3).adjacentMinesCount == 1);
    assert(board.testGetCell(2, 4).adjacentMinesCount == 1);
    assert(board.testGetCell(3, 2).adjacentMinesCount == 1);
    assert(board.testGetCell(3, 4).adjacentMinesCount == 1);
    assert(board.testGetCell(4, 2).adjacentMinesCount == 1);
    assert(board.testGetCell(4, 3).adjacentMinesCount == 1);
    assert(board.testGetCell(4, 4).adjacentMinesCount == 1);

    // Cells further away should have adjacentMinesCount = 0
    assert(board.testGetCell(1, 1).adjacentMinesCount == 0);
    assert(board.testGetCell(1, 5).adjacentMinesCount == 0);

    // Test with multiple mines
    TestBoard multiBoard(5, 5, 0);
    multiBoard.testGetCell(2, 2).setHasMine(true);
    multiBoard.testGetCell(2, 3).setHasMine(true);
    multiBoard.testCalcAdjacentMines();

    // Cell (3, 2) should see 2 mines, cell (3, 3) should see 2 mines
    assert(multiBoard.testGetCell(3, 2).adjacentMinesCount == 2);
    assert(multiBoard.testGetCell(3, 3).adjacentMinesCount == 2);

    // Cell (1, 2) should see 2 mines (adjacent to both)
    assert(multiBoard.testGetCell(1, 2).adjacentMinesCount == 2);
    assert(multiBoard.testGetCell(1, 3).adjacentMinesCount == 2);

    std::cout << " PASSED\n";
}

// ========= Test 7: Boundary Conditions - Safe Zone at Board Corners ========= //
void testSafeZoneAtCorners()
{
    std::cout << "Test 7: Boundary Conditions (Safe Zone at Board Corners)...";

    // Test safe zone at top-left corner (1, 1)
    TestBoard cornerBoard(9, 9, 10);
    cornerBoard.testPlaceMines(1, 1);

    // The 3x3 safe zone around (1, 1) extends from (0,0) to (2,2)
    // But (0, x) and (x, 0) are walls, so only check valid playable cells
    for (int r = 1; r <= 2; r++)
    {
        for (int c = 1; c <= 2; c++)
        {
            Cell &cell = cornerBoard.testGetCell(r, c);
            assert(!cell.hasMine); // Safe zone should have no mines
        }
    }

    // Test safe zone at bottom-right corner
    TestBoard cornerBoard2(9, 9, 10);
    cornerBoard2.testPlaceMines(9, 9);

    // Check the safe zone near bottom-right (rows 8-9, cols 8-9 are playable)
    for (int r = 8; r <= 9; r++)
    {
        for (int c = 8; c <= 9; c++)
        {
            Cell &cell = cornerBoard2.testGetCell(r, c);
            assert(!cell.hasMine); // Safe zone should have no mines
        }
    }

    std::cout << " PASSED\n";
}

// ========= Test 8: Stress Test - High Mine Density ========= //
void testHighMineDensity()
{
    std::cout << "Test 8: Stress Test (High Mine Density)...";

    // Create a 9x9 board with very high mine count
    // 9x9 = 81 cells, minus 9 for safe zone = 72 possible mine positions
    // This tests that the algorithm terminates properly even with extreme density
    TestBoard denseBoard(9, 9, 60);

    denseBoard.testPlaceMines(5, 5);

    int mineCount = denseBoard.countTotalMines();

    // Should place as many mines as possible without creating unsolvable patterns
    // May not place all 60 due to pattern restrictions, but should terminate
    assert(mineCount > 0);
    assert(mineCount <= 60);

    // Verify safe zone still has no mines
    for (int r = 4; r <= 6; r++)
    {
        for (int c = 4; c <= 6; c++)
        {
            Cell &cell = denseBoard.testGetCell(r, c);
            assert(!cell.hasMine);
        }
    }

    std::cout << " PASSED\n";
}

int main()
{
    std::cout << "\n=== Running Tests for Checkpoint 3: Mine Placement Algorithm ===\n\n";

    try
    {
        testNormalOperation();
        testFormsTwoByTwo();
        testFormsLongLine();
        testTrapsSafeCell();
        testKeyAndBlacklist();
        testCalcAdjacentMines();
        testSafeZoneAtCorners();
        testHighMineDensity();

        std::cout << "\n✅ All tests passed!\n";
        return 0;
    }
    catch (const std::exception &e)
    {
        std::cerr << "\n❌ Test failed with exception: " << e.what() << "\n";
        return 1;
    }
}
