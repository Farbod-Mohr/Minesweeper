#include <unordered_map>
#include <string>
#include <string_view>
#include <vector>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <chrono>
#include <thread>
#include "../include/Game.h"
#include "../include/HighScoreSaver.h"
#include <cassert>
#include <iostream>

// ! UNIT TESTS ARE GENERATED BY GITHUB COPILOT. !
// ? Prompt used: Create unit tests for checkpoint 4. Checkpoint 4 is calculating the game's time and high score saving. ? //
// * AI Used: Claude Opus 4.5 (Preview) * //

// ========= Test Helper Class for HighScoreSaver ========= //
// Since HighScoreSaver has private members and calls saveToFile() internally,
// we test the time conversion functions separately and manually test score logic
class TestHighScoreSaver
{
public:
    static const int MAX_SCORES = 5;
    int highScores[3][MAX_SCORES] = {};

    // Helper to convert time string to seconds
    int timeStringToSeconds(const std::string &timeStr) const
    {
        int hours = 0, minutes = 0, seconds = 0;
#ifdef _WIN32
        sscanf_s(timeStr.c_str(), "%d:%d:%d", &hours, &minutes, &seconds);
#else
        sscanf(timeStr.c_str(), "%d:%d:%d", &hours, &minutes, &seconds);
#endif
        return hours * 3600 + minutes * 60 + seconds;
    }

    // Helper to format seconds back to HH:MM:SS
    std::string secondsFormat(long long seconds) const
    {
        if (seconds == 0)
        {
            return "--------";
        }
        const long long hours = seconds / 3600;
        const long long minutes = (seconds % 3600) / 60;
        const long long secs = seconds % 60;

        std::stringstream ss;
        ss << std::setfill('0') << std::setw(2) << hours << ":"
           << std::setfill('0') << std::setw(2) << minutes << ":"
           << std::setfill('0') << std::setw(2) << secs;
        return ss.str();
    }

    // Get difficulty index (0=Easy, 1=Medium, 2=Hard)
    int getDifficultyIndex(const std::string &diffName) const
    {
        if (diffName == "EASY")
            return 0;
        if (diffName == "MEDIUM")
            return 1;
        if (diffName == "HARD")
            return 2;
        return -1;
    }

    // Add score without file saving (for testing)
    void addScore(const std::string &time, const std::string &diffName)
    {
        int diffIndex = getDifficultyIndex(diffName);
        int timeInSeconds = timeStringToSeconds(time);

        int insertPos = -1;
        for (int i = 0; i < MAX_SCORES; i++)
        {
            if (highScores[diffIndex][i] == 0 || timeInSeconds < highScores[diffIndex][i])
            {
                insertPos = i;
                break;
            }
        }

        if (insertPos == -1)
            return;

        for (int i = MAX_SCORES - 1; i > insertPos; i--)
        {
            highScores[diffIndex][i] = highScores[diffIndex][i - 1];
        }

        highScores[diffIndex][insertPos] = timeInSeconds;
    }

    const int *getHighScores(const std::string &diffName) const
    {
        return highScores[getDifficultyIndex(diffName)];
    }
};

// ========= Test 1: Normal Operation - Time String to Seconds Conversion ========= //
void testTimeStringToSeconds()
{
    std::cout << "Test 1: Normal Operation (Time String to Seconds Conversion)...";

    TestHighScoreSaver saver;

    // Test basic conversions
    assert(saver.timeStringToSeconds("00:00:00") == 0);
    assert(saver.timeStringToSeconds("00:00:01") == 1);
    assert(saver.timeStringToSeconds("00:01:00") == 60);
    assert(saver.timeStringToSeconds("01:00:00") == 3600);

    // Test combined time
    assert(saver.timeStringToSeconds("01:30:45") == 5445); // 3600 + 1800 + 45
    assert(saver.timeStringToSeconds("00:05:30") == 330);  // 300 + 30

    std::cout << " PASSED\n";
}

// ========= Test 2: Normal Operation - Seconds to Time String Formatting ========= //
void testSecondsFormat()
{
    std::cout << "Test 2: Normal Operation (Seconds to Time String Formatting)...";

    TestHighScoreSaver saver;

    // Test zero returns placeholder
    assert(saver.secondsFormat(0) == "--------");

    // Test basic formatting
    assert(saver.secondsFormat(1) == "00:00:01");
    assert(saver.secondsFormat(60) == "00:01:00");
    assert(saver.secondsFormat(3600) == "01:00:00");

    // Test combined time
    assert(saver.secondsFormat(5445) == "01:30:45");
    assert(saver.secondsFormat(330) == "00:05:30");

    // Test edge cases
    assert(saver.secondsFormat(59) == "00:00:59");
    assert(saver.secondsFormat(3599) == "00:59:59");
    assert(saver.secondsFormat(86399) == "23:59:59"); // Max reasonable time

    std::cout << " PASSED\n";
}

// ========= Test 3: Edge Case - Round Trip Conversion ========= //
void testRoundTripConversion()
{
    std::cout << "Test 3: Edge Case (Round Trip Conversion)...";

    TestHighScoreSaver saver;

    // Test that converting to seconds and back gives the same result
    std::string times[] = {"00:01:23", "00:15:00", "01:00:00", "02:30:45", "00:00:59"};

    for (const auto &time : times)
    {
        int seconds = saver.timeStringToSeconds(time);
        std::string result = saver.secondsFormat(seconds);
        assert(result == time);
    }

    std::cout << " PASSED\n";
}

// ========= Test 4: Normal Operation - Add Score and Retrieve ========= //
void testAddScoreAndRetrieve()
{
    std::cout << "Test 4: Normal Operation (Add Score and Retrieve)...";

    TestHighScoreSaver saver;

    // Add a score for Easy mode
    saver.addScore("00:05:30", "EASY");

    // Retrieve scores for Easy difficulty
    const int *scores = saver.getHighScores("EASY");

    // The score should be stored (330 seconds)
    assert(scores[0] == 330);

    std::cout << " PASSED\n";
}

// ========= Test 5: Boundary Conditions - Score Sorting ========= //
void testScoreSorting()
{
    std::cout << "Test 5: Boundary Conditions (Score Sorting)...";

    TestHighScoreSaver saver;

    // Add scores in non-sorted order
    saver.addScore("00:10:00", "EASY"); // 600 seconds
    saver.addScore("00:05:00", "EASY"); // 300 seconds (better)
    saver.addScore("00:07:30", "EASY"); // 450 seconds

    const int *scores = saver.getHighScores("EASY");

    // Scores should be sorted from best (lowest) to worst (highest)
    assert(scores[0] == 300); // Best: 00:05:00
    assert(scores[1] == 450); // Second: 00:07:30
    assert(scores[2] == 600); // Third: 00:10:00

    std::cout << " PASSED\n";
}

// ========= Test 6: Boundary Conditions - Max 5 Scores ========= //
void testMaxFiveScores()
{
    std::cout << "Test 6: Boundary Conditions (Max 5 Scores Limit)...";

    TestHighScoreSaver saver;

    // Add 6 scores - only top 5 should be kept
    saver.addScore("00:10:00", "MEDIUM"); // 600
    saver.addScore("00:08:00", "MEDIUM"); // 480
    saver.addScore("00:06:00", "MEDIUM"); // 360
    saver.addScore("00:04:00", "MEDIUM"); // 240
    saver.addScore("00:02:00", "MEDIUM"); // 120
    saver.addScore("00:05:00", "MEDIUM"); // 300 - should push out 600

    const int *scores = saver.getHighScores("MEDIUM");

    // Should have top 5: 120, 240, 300, 360, 480
    assert(scores[0] == 120);
    assert(scores[1] == 240);
    assert(scores[2] == 300);
    assert(scores[3] == 360);
    assert(scores[4] == 480);

    std::cout << " PASSED\n";
}

// ========= Test 7: Edge Case - Different Difficulties Separate ========= //
void testDifferentDifficultiesSeparate()
{
    std::cout << "Test 7: Edge Case (Different Difficulties Stored Separately)...";

    TestHighScoreSaver saver;

    // Add different scores to each difficulty
    saver.addScore("00:01:00", "EASY");   // 60 seconds
    saver.addScore("00:02:00", "MEDIUM"); // 120 seconds
    saver.addScore("00:03:00", "HARD");   // 180 seconds

    // Each difficulty should have its own score
    const int *easyScores = saver.getHighScores("EASY");
    const int *medScores = saver.getHighScores("MEDIUM");
    const int *hardScores = saver.getHighScores("HARD");

    assert(easyScores[0] == 60);
    assert(medScores[0] == 120);
    assert(hardScores[0] == 180);

    // Scores should not interfere with each other
    assert(easyScores[1] == 0); // No second score for easy
    assert(medScores[1] == 0);  // No second score for medium

    std::cout << " PASSED\n";
}

// ========= Test 8: Edge Case - Score Not Good Enough ========= //
void testScoreNotGoodEnough()
{
    std::cout << "Test 8: Edge Case (Score Not Good Enough to Save)...";

    TestHighScoreSaver saver;

    // Fill with 5 good scores
    saver.addScore("00:01:00", "EASY"); // 60
    saver.addScore("00:02:00", "EASY"); // 120
    saver.addScore("00:03:00", "EASY"); // 180
    saver.addScore("00:04:00", "EASY"); // 240
    saver.addScore("00:05:00", "EASY"); // 300

    const int *scores = saver.getHighScores("EASY");

    // Verify initial state
    assert(scores[4] == 300); // Worst score is 300

    // Try to add a worse score (should not be saved)
    saver.addScore("00:10:00", "EASY"); // 600 - worse than all

    // Score list should be unchanged
    assert(scores[0] == 60);
    assert(scores[1] == 120);
    assert(scores[2] == 180);
    assert(scores[3] == 240);
    assert(scores[4] == 300); // Still 300, not 600

    std::cout << " PASSED\n";
}

int main()
{
    std::cout << "\n=== Running Tests for Checkpoint 4: Time Calculation & High Score Saving ===\n\n";

    try
    {
        testTimeStringToSeconds();
        testSecondsFormat();
        testRoundTripConversion();
        testAddScoreAndRetrieve();
        testScoreSorting();
        testMaxFiveScores();
        testDifferentDifficultiesSeparate();
        testScoreNotGoodEnough();

        std::cout << "\n✅ All tests passed!\n";
        return 0;
    }
    catch (const std::exception &e)
    {
        std::cerr << "\n❌ Test failed with exception: " << e.what() << "\n";
        return 1;
    }
}
