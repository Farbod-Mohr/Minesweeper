#include <unordered_map>
#include <string>
#include <string_view>
#include <vector>
#include "../include/Board.h"
#include "../include/Cell.h"
#include <cassert>
#include <iostream>

// ! UNIT TESTS ARE GENERATED BY GITHUB COPILOT. !
// ? Prompt used: According to the how to the test document, create unit tests for checkpoint 2 of the project. Checkpoint 2 is the rendering of the minesweeper board and interaction with it. ? //
// * AI Used: Claude Opus 4.5 (Preview) * //

// ========= Test Helper Class ========= //
// Since Board has many private members, we create a TestBoard class that inherits from Board
// to expose the necessary functionality for testing purposes.
class TestBoard : public Board
{
public:
    TestBoard(int rows, int cols, int mineCount) : Board(rows, cols, mineCount) {}

    // Expose the grid for testing
    std::vector<std::vector<Cell>> &getGrid() { return grid; }

    // Expose cell access for testing
    Cell &testGetCell(int r, int c) { return grid[r][c]; }

    // Expose selected cell for testing
    Cell *getSelectedCell() { return selectedCell; }

    // Expose movement methods for testing
    void testMoveCursorUp() { moveCursorUp(); }
    void testMoveCursorDown() { moveCursorDown(); }
    void testMoveCursorLeft() { moveCursorLeft(); }
    void testMoveCursorRight() { moveCursorRight(); }

    // Expose dig and flag methods for testing
    bool testDigCell(int r, int c) { return digCell(r, c); }
    void testToggleFlagCell(int r, int c) { toggleFlagCell(r, c); }

    // Expose select/unselect for testing
    void testSelectCell(int r, int c) { selectCell(r, c); }

    // Expose counters for testing
    int getRows() const { return rows; }
    int getCols() const { return cols; }
    int getTotalCells() const { return totalCells; }
    int getDugCount() const { return dugCount; }
    int getFlagCount() const { return flagCount; }
    int getMinesRemaining() const { return minesRemaining; }
};

// ========= Test 1: Normal Operation - Board Initialization and Cell Rendering ========= //
void testNormalOperation()
{
    std::cout << "Test 1: Normal Operation (Board Initialization & Cell Rendering)...";

    // Create a 9x9 board with 10 mines (like Easy difficulty)
    TestBoard board(9, 9, 10);

    // Verify board dimensions (9+2 walls = 11 in each direction)
    assert(board.getRows() == 11);
    assert(board.getCols() == 11);
    assert(board.getTotalCells() == 81); // 9x9 = 81 playable cells

    // Verify wall cells are correctly placed on borders
    Cell &topLeftWall = board.testGetCell(0, 0);
    assert(topLeftWall.state == WALL);
    assert(topLeftWall.print().find("#") != std::string::npos);

    Cell &bottomRightWall = board.testGetCell(10, 10);
    assert(bottomRightWall.state == WALL);

    // Verify inner cells are NORMAL state
    Cell &innerCell = board.testGetCell(1, 1);
    assert(innerCell.state == NORMAL);
    assert(innerCell.print().find("+") != std::string::npos);

    // Verify a cell is selected by default (cursor starts at position 1,1)
    Cell *selected = board.getSelectedCell();
    assert(selected != nullptr);
    assert(selected->isSelected == true);

    std::cout << " PASSED\n";
}

// ========= Test 2: Edge Case - Cell State Transitions and Rendering ========= //
void testEdgeCase()
{
    std::cout << "Test 2: Edge Case (Cell State Transitions & Rendering)...";

    // Test Cell rendering for each state
    Cell normalCell(NORMAL, 1, 1);
    assert(normalCell.state == NORMAL);
    std::string normalPrint = normalCell.print();
    assert(normalPrint.find("+") != std::string::npos);

    Cell flaggedCell(FLAGGED, 2, 2);
    assert(flaggedCell.state == FLAGGED);
    std::string flaggedPrint = flaggedCell.print();
    assert(flaggedPrint.find("F") != std::string::npos);

    Cell explodedCell(EXPLODED, 3, 3);
    assert(explodedCell.state == EXPLODED);
    std::string explodedPrint = explodedCell.print();
    assert(explodedPrint.find("X") != std::string::npos);

    Cell wallCell(WALL, 0, 0);
    assert(wallCell.state == WALL);
    std::string wallPrint = wallCell.print();
    assert(wallPrint.find("#") != std::string::npos);

    // Test DUG cell with different adjacent mine counts
    Cell dugCellZero(DUG, 4, 4);
    dugCellZero.setAdjacentMinesCount(0);
    std::string dugZeroPrint = dugCellZero.print();
    assert(dugZeroPrint.find(" ") != std::string::npos); // Empty space for 0 mines

    Cell dugCellThree(DUG, 5, 5);
    dugCellThree.setAdjacentMinesCount(3);
    std::string dugThreePrint = dugCellThree.print();
    assert(dugThreePrint.find("3") != std::string::npos);

    // Test selected cell rendering (should have cyan color)
    Cell selectedCell(NORMAL, 6, 6);
    selectedCell.setSelected(true);
    assert(selectedCell.isSelected == true);
    // Selected cells should render differently (with color codes)
    std::string selectedPrint = selectedCell.print();
    assert(selectedPrint.length() > 1); // Has color codes

    std::cout << " PASSED\n";
}

// ========= Test 3: Boundary Conditions - Cursor Movement and Flagging ========= //
void testBoundaryConditions()
{
    std::cout << "Test 3: Boundary Conditions (Cursor Movement & Flagging)...";

    // Create a small 3x3 board to test boundary movement
    TestBoard board(3, 3, 1);

    // Board is 5x5 with walls (3+2 = 5)
    assert(board.getRows() == 5);
    assert(board.getCols() == 5);

    // Initial selection should be at (1,1)
    Cell *selected = board.getSelectedCell();
    assert(selected != nullptr);
    assert(selected->x == 1 && selected->y == 1);

    // Test moving cursor to boundaries
    // Move right twice (from col 1 to col 3 - rightmost playable column)
    board.testMoveCursorRight();
    board.testMoveCursorRight();
    selected = board.getSelectedCell();
    assert(selected->x == 3); // Should be at rightmost column

    // Try to move right again - should stay at boundary (can't go into wall)
    board.testMoveCursorRight();
    selected = board.getSelectedCell();
    assert(selected->x == 3); // Should still be at rightmost column

    // Move down twice (from row 1 to row 3 - bottom row)
    board.testMoveCursorDown();
    board.testMoveCursorDown();
    selected = board.getSelectedCell();
    assert(selected->y == 3); // Should be at bottom row

    // Try to move down again - should stay at boundary
    board.testMoveCursorDown();
    selected = board.getSelectedCell();
    assert(selected->y == 3); // Should still be at bottom row

    // Test flagging a cell
    assert(board.getFlagCount() == 0);
    assert(board.getMinesRemaining() == 1);

    // Flag the current cell
    board.testToggleFlagCell(selected->y, selected->x);
    assert(board.getFlagCount() == 1);
    assert(board.getMinesRemaining() == 0);

    // Unflag the cell
    board.testToggleFlagCell(selected->y, selected->x);
    assert(board.getFlagCount() == 0);
    assert(board.getMinesRemaining() == 1);

    std::cout << " PASSED\n";
}

// ========= Test 4: Digging Cells and Recursive Reveal ========= //
void testDiggingCells()
{
    std::cout << "Test 4: Digging Cells (Cell Dig Logic)...";

    // Create a small board
    TestBoard board(3, 3, 0); // No mines for this test

    // Initially no cells are dug
    assert(board.getDugCount() == 0);

    // Dig a cell at position (1,1)
    Cell &cell = board.testGetCell(1, 1);
    assert(cell.state == NORMAL);

    bool hitMine = board.testDigCell(1, 1);
    assert(hitMine == false); // No mine was hit
    assert(cell.state == DUG);
    assert(board.getDugCount() > 0); // At least one cell should be dug

    // Digging an already dug cell should do nothing
    int dugBefore = board.getDugCount();
    hitMine = board.testDigCell(1, 1);
    assert(hitMine == false);
    assert(board.getDugCount() == dugBefore); // Count should not change

    // Test digging a cell with a mine
    Cell &mineCell = board.testGetCell(2, 2);
    mineCell.setHasMine(true);
    mineCell.setState(NORMAL); // Reset to normal state

    hitMine = board.testDigCell(2, 2);
    assert(hitMine == true); // Mine was hit
    assert(mineCell.state == EXPLODED);

    std::cout << " PASSED\n";
}

// ========= Test 5: Adjacent Mines Count Display ========= //
void testAdjacentMinesDisplay()
{
    std::cout << "Test 5: Adjacent Mines Count Display...";

    // Test that dug cells display correct numbers based on adjacent mines
    Cell cell(DUG, 1, 1);

    // Test all possible adjacent mine counts (0-8)
    for (int i = 0; i <= 8; i++)
    {
        cell.setAdjacentMinesCount(i);
        std::string display = cell.print();

        if (i == 0)
        {
            // Should display empty space for 0 adjacent mines
            assert(display.find(" ") != std::string::npos);
        }
        else
        {
            // Should display the number
            assert(display.find(std::to_string(i)) != std::string::npos);
        }
    }

    std::cout << " PASSED\n";
}

// ========= Test 6: Board Size Variations ========= //
void testBoardSizeVariations()
{
    std::cout << "Test 6: Board Size Variations (Different Difficulties)...";

    // Test Easy difficulty size (9x9)
    TestBoard easyBoard(9, 9, 10);
    assert(easyBoard.getRows() == 11);
    assert(easyBoard.getCols() == 11);
    assert(easyBoard.getTotalCells() == 81);

    // Test Medium difficulty size (16x16)
    TestBoard mediumBoard(16, 16, 40);
    assert(mediumBoard.getRows() == 18);
    assert(mediumBoard.getCols() == 18);
    assert(mediumBoard.getTotalCells() == 256);

    // Test Hard difficulty size (16x30)
    TestBoard hardBoard(16, 30, 99);
    assert(hardBoard.getRows() == 18);
    assert(hardBoard.getCols() == 32);
    assert(hardBoard.getTotalCells() == 480);

    // Verify all boards have walls properly placed
    for (int c = 0; c < 11; c++)
    {
        assert(easyBoard.testGetCell(0, c).state == WALL);       // Top wall
        assert(easyBoard.testGetCell(10, c).state == WALL);      // Bottom wall
    }
    for (int r = 0; r < 11; r++)
    {
        assert(easyBoard.testGetCell(r, 0).state == WALL);       // Left wall
        assert(easyBoard.testGetCell(r, 10).state == WALL);      // Right wall
    }

    std::cout << " PASSED\n";
}

int main()
{
    std::cout << "\n=== Running Tests for Checkpoint 2: Board Rendering & Interaction ===\n\n";

    try
    {
        testNormalOperation();
        testEdgeCase();
        testBoundaryConditions();
        testDiggingCells();
        testAdjacentMinesDisplay();
        testBoardSizeVariations();

        std::cout << "\n✅ All tests passed!\n";
        return 0;
    }
    catch (const std::exception &e)
    {
        std::cerr << "\n❌ Test failed with exception: " << e.what() << "\n";
        return 1;
    }
}
